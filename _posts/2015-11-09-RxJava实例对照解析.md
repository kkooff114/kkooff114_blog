---
layout:         post
title:          RxJava实例对照解析
description:    RxJava如何应用于生产环境的常用代码
tags:           RxJava
keywords:       RxJava
---

# RxJava实例对照解析

>RxJava如何引用于生产环境的常用代码解析
	
	
[TOC]


## 基本

``` java
_subscription = _getObservable()//
      .subscribeOn(Schedulers.io())
      .observeOn(AndroidSchedulers.mainThread())
      .subscribe(_getObserver());
      
   /**
  	* Observer that handles the result through the 3 important actions:
     *
     * 1. onCompleted
     * 2. onError
     * 3. onNext
     */
  private Observer<Boolean> _getObserver() {
        return new Observer<Boolean>() {

            @Override
            public void onCompleted() {
                _log("On complete");
                _progress.setVisibility(View.INVISIBLE);
            }

            @Override
            public void onError(Throwable e) {
                Timber.e(e, "Error in RxJava Demo concurrency");
                _log(String.format("Boo! Error %s", e.getMessage()));
                _progress.setVisibility(View.INVISIBLE);
            }

            @Override
            public void onNext(Boolean bool) {
                _log(String.format("onNext with return value \"%b\"", bool));
            }
        };
    }

private Observable<Boolean> _getObservable() {
    return Observable.just(true).map(new Func1<Boolean, Boolean>() {
        @Override
        public Boolean call(Boolean aBoolean) {
            _log("Within Observable");
            _doSomeLongOperation_thatBlocksCurrentThread();
            return aBoolean;
        }
    });
}
```

>***注解:***

`just`: 发送一次广播.

`new Func1<参数1, 参数2>`: 参数1 传入参数; 参数2 为 返回参数.

`subscribeOn`: 为被订阅者运行的线程.

`observeOn`: 为观察者运行的线程.

`Schedulers.io()`: IO线程.

`AndroidSchedulers.mainThread()`: Android UI线程.

`subscribe`: 接受Observer<T>的参数, 即被订阅者发出的事件.

------

## buffer

``` java
private Subscription _getBufferedSubscription() {
    return RxView.clickEvents(_tapBtn)
          .map(new Func1<ViewClickEvent, Integer>() {
              @Override
              public Integer call(ViewClickEvent onClickEvent) {
                  Timber.d("--------- GOT A TAP");
                  _log("GOT A TAP");
                  return 1;
              }
          })
          .buffer(2, TimeUnit.SECONDS)
          .observeOn(AndroidSchedulers.mainThread())
          .subscribe(new Observer<List<Integer>>() {

              @Override
              public void onCompleted() {
                  // fyi: you'll never reach here
                  Timber.d("----- onCompleted");
              }

              @Override
              public void onError(Throwable e) {
                  Timber.e(e, "--------- Woops on error!");
                  _log("Dang error! check your logs");
              }

              @Override
              public void onNext(List<Integer> integers) {
                  Timber.d("--------- onNext");
                  if (integers.size() > 0) {
                      _log(String.format("%d taps", integers.size()));
                  } else {
                      Timber.d("--------- No taps received ");
                  }
              }
          });
}
```

>***注解:***

`buffer`: 接受一个时间参数; 表示在缓冲在这段时间内的所有Observable发出的事件; 并在参数时间**周期结束**的时候, 调用subscribe的方法执行这些事件.

---

## debounce

```java
_subscription = RxTextView.textChangeEvents(_inputSearchText)//
              .debounce(400, TimeUnit.MILLISECONDS)// default Scheduler is Computation
              .observeOn(AndroidSchedulers.mainThread())//
              .subscribe(_getSearchObserver());
```

>***注解:***

`debounce`: 接受一个时间参数; 当收到Observable发出的一个事件后, 在参数时间内如果没有**再次**收到Observable发出的事件的时候, 调用subscribe的方法执行这些事件. 

---



