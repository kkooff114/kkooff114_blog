---
layout:         post
title:          WRK好用的网络压测工具
description:    wrk小巧轻盈的 http 性能测试工具
tags:           wrk, 压测, http
keywords:       wrk, 压测, http
noToc: 			  true
---

[TOC]

#项目地址
>https://github.com/wg/wrk

#编译
项目只支持Unix 类的系统

```java
git clone https://github.com/wg/wrk.git  
cd wrk  
make 
```
编译完成后项目目录下面就会出现一个`wrk`的文件, 这个就是我们想要的了
将`wrk`拷贝到`/usr/local/bin/`路径下, 就可以直接在终端使用了
或使用命令直接建立软连接:

```
ln -s wrk /usr/local/bin/wrk
```

#使用
首先直接简单使用

```
wrk -t12 -c100 -d30s http://www.baidu.com  
```
30s后会得到

```
➜  wrk git:(master) wrk -t12 -c100 -d30s http://www.baidu.com   
Running 30s test @ http://www.baidu.com
  12 threads and 100 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   673.16ms  391.50ms   2.00s    74.16%
    Req/Sec    12.52      7.93    59.00     76.96%
  3869 requests in 30.10s, 57.24MB read
  Socket errors: connect 0, read 0, write 0, timeout 117
Requests/sec:    128.53
Transfer/sec:      1.90MB
```
###参数说明
####请求
`-t12` 12个线程
`-c100` 100个链接
`-d30s` 运行30秒,通过 -d 可以设置测试的持续时间. 一般只要不是太短都是可以的. 看你自己的忍耐程度了. 时间越长样本越准确. 如果想测试系统的持续抗压能力, 采用 loadrunner 这样的专业测试工具会更好一点. 
####返回
`Latency`: 可以理解为响应时间, 有平均值, 标准偏差, 最大值, 正负一个标准差占比. 
`Req/Sec`: 每个线程每秒钟的完成的请求数, 同样有平均值, 标准偏差, 最大值, 正负一个标准差占比. 

接着:
```
 5073 requests in 30.09s, 75.28MB read  
  Socket errors: connect 0, read 5, write 0, timeout 64  
Requests/sec:    168.59  
Transfer/sec:      2.50MB  
```
0秒钟总共完成请求数和读取数据量. 
然后是错误统计, 上面的统计可以看到, 5个读错误, 64个超时. 
然后是所以线程总共平均每秒钟完成168个请求. 每秒钟读取2.5兆数据量. 

可以看到, 相对于专业性能测试工具. wrk 的统计信息是非常简单的. 但是这些信息基本上足够我们判断系统是否有问题了. 

wrk 默认超时时间是1秒. 这个有点短. 我一般设置为30秒. 这个看上去合理一点. 
如果这样执行命令: 

```
/wrk -t12 -c100 -d30s -T30s http://www.baidu.com  
```

`--latency`想看看响应时间的分布情况可以加上`--latency`参数: 

```
wrk -t12 -c100 -d30s -T30s --latency http://www.baidu.com 
```

```
Running 30s test @ http://www.baidu.com  
  12 threads and 100 connections  
  Thread Stats   Avg      Stdev     Max   +/- Stdev  
    Latency     1.22s     1.88s   17.59s    89.70%  
    Req/Sec    14.47      9.92    98.00     77.06%  
  Latency Distribution  
     50%  522.18ms  
     75%    1.17s  
     90%    3.22s  
     99%    8.87s  
  3887 requests in 30.09s, 57.82MB read  
  Socket errors: connect 0, read 2, write 0, timeout 0  
Requests/sec:    129.19  
Transfer/sec:      1.92MB 
```
可以看到50%在0.5秒以内, %75在1.2s 以内. 看上去还不错. 

看到这里可能有人会说了, HTTP 请求不会总是这么简单的, 通常我们会有 POST,GET 等多个 method, 会有 Header, 会有 body 等. 


#Lua脚本
需要修改 method, header, body,等时就需要使用lua脚本了
首先创建一个 `post.lua` 的文件: 

```lua
wrk.method = "POST"  
wrk.body   = "foo=bar&baz=quux"  
wrk.headers["Content-Type"] = "application/x-www-form-urlencoded"  
```

然后发送请求

```
wrk -t12 -c100 -d30s -T30s --script=post.lua --latency http://www.baidu.com  
```

wrk的对象属性

```lua
local wrk = {  
   scheme  = "http",  
   host    = "localhost",  
   port    = nil,  
   method  = "GET",  
   path    = "/",  
   headers = {},  
   body    = nil,  
   thread  = nil,  
}  
```

wrk 提供的几个 lua 的 hook 函数: 
`setup 函数 `
这个函数在目标 IP 地址已经解析完, 并且所有 thread 已经生成, 但是还没有开始时被调用. 每个线程执行一次这个函数. 
可以通过thread:get(name),  thread:set(name, value)设置线程级别的变量. 

`init 函数 `
每次请求发送之前被调用. 
可以接受 wrk 命令行的额外参数. 通过 -- 指定. 

`delay函数 `
这个函数返回一个数值, 在这次请求执行完以后延迟多长时间执行下一个请求. 可以对应 thinking time 的场景. 

`request函数 `
通过这个函数可以每次请求之前修改本次请求的属性. 返回一个字符串. 这个函数要慎用, 会影响测试端性能. 

一个完整的例子:

```lua
local counter = 1  
local threads = {}  
  
function setup(thread)  
   thread:set("id", counter)  
   table.insert(threads, thread)  
   counter = counter + 1  
end  
  
function init(args)  
   requests  = 0  
   responses = 0  
  
   local msg = "thread %d created"  
   print(msg:format(id))  
end  
  
function request()  
   requests = requests + 1  
   return wrk.request()  
end  
  
function response(status, headers, body)  
   responses = responses + 1  
end  
  
function done(summary, latency, requests)  
   for index, thread in ipairs(threads) do  
      local id        = thread:get("id")  
      local requests  = thread:get("requests")  
      local responses = thread:get("responses")  
      local msg = "thread %d made %d requests and got %d responses"  
      print(msg:format(id, requests, responses))  
   end  
end  
```


#jmeter

