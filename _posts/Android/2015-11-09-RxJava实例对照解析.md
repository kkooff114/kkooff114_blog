---
layout:         post
title:          RxJava实例对照解析
description:    RxJava如何应用于生产环境的常用代码
tags:           RxJava
keywords:       RxJava
noToc: 			  true
---

# RxJava实例对照解析

>RxJava如何引用于生产环境的常用代码解析
	
	
[TOC]


## 基本

``` java
_subscription = _getObservable()//
      .subscribeOn(Schedulers.io())
      .observeOn(AndroidSchedulers.mainThread())
      .subscribe(_getObserver());
      
   /**
  	* Observer that handles the result through the 3 important actions:
     *
     * 1. onCompleted
     * 2. onError
     * 3. onNext
     */
  private Observer<Boolean> _getObserver() {
        return new Observer<Boolean>() {

            @Override
            public void onCompleted() {
                _log("On complete");
                _progress.setVisibility(View.INVISIBLE);
            }

            @Override
            public void onError(Throwable e) {
                Timber.e(e, "Error in RxJava Demo concurrency");
                _log(String.format("Boo! Error %s", e.getMessage()));
                _progress.setVisibility(View.INVISIBLE);
            }

            @Override
            public void onNext(Boolean bool) {
                _log(String.format("onNext with return value \"%b\"", bool));
            }
        };
    }

private Observable<Boolean> _getObservable() {
    return Observable.just(true).map(new Func1<Boolean, Boolean>() {
        @Override
        public Boolean call(Boolean aBoolean) {
            _log("Within Observable");
            _doSomeLongOperation_thatBlocksCurrentThread();
            return aBoolean;
        }
    });
}
```

>***注解:***

`just`: 发送一次广播.

`new Func1<参数1, 参数2>`: 参数1 传入参数; 参数2 为 返回参数.

`subscribeOn`: 为被订阅者运行的线程.

`observeOn`: 为观察者运行的线程.

`Schedulers.io()`: IO线程.

`AndroidSchedulers.mainThread()`: Android UI线程.

`subscribe`: 接受Observer<T>的参数, 即被订阅者发出的事件.

------

## buffer

``` java
private Subscription _getBufferedSubscription() {
    return RxView.clickEvents(_tapBtn)
          .map(new Func1<ViewClickEvent, Integer>() {
              @Override
              public Integer call(ViewClickEvent onClickEvent) {
                  Timber.d("--------- GOT A TAP");
                  _log("GOT A TAP");
                  return 1;
              }
          })
          .buffer(2, TimeUnit.SECONDS)
          .observeOn(AndroidSchedulers.mainThread())
          .subscribe(new Observer<List<Integer>>() {

              @Override
              public void onCompleted() {
                  // fyi: you'll never reach here
                  Timber.d("----- onCompleted");
              }

              @Override
              public void onError(Throwable e) {
                  Timber.e(e, "--------- Woops on error!");
                  _log("Dang error! check your logs");
              }

              @Override
              public void onNext(List<Integer> integers) {
                  Timber.d("--------- onNext");
                  if (integers.size() > 0) {
                      _log(String.format("%d taps", integers.size()));
                  } else {
                      Timber.d("--------- No taps received ");
                  }
              }
          });
}
```

>***注解:***

`buffer`: 接受一个时间参数; 表示在缓冲在这段时间内的所有Observable发出的事件; 并在参数时间**周期结束**的时候, 调用subscribe的方法执行这些事件.

---

## debounce

```java
_subscription = RxTextView.textChangeEvents(_inputSearchText)//
              .debounce(400, TimeUnit.MILLISECONDS)// default Scheduler is Computation
              .observeOn(AndroidSchedulers.mainThread())//
              .subscribe(_getSearchObserver());
```

>***注解:***

`debounce`: 接受一个时间参数; 当收到Observable发出的一个事件后, 在参数时间内如果没有**再次**收到Observable发出的事件的时候, 调用subscribe的方法执行这些事件. 

---

## doNext
场景:
输入开始时间, 结束时间, 从数据库中查出这个区间范围内的数据
输入: [Date, Date], Date类型的数组
输出: ArrayList<ArrayList<CrmDz>> 从数据库中查出的二维列表

```java
PublishSubject<Date[]> mTimeSearchResultSubject; // 定义一个发布者
Subscription mTimeSearchSubscription;  // 定义一个订阅者, 便于unsubscribe();

private void setupSearchTime() {
	mTimeSearchResultSubject = PublishSubject.create();
	mTimeSearchSubscription = mTimeSearchResultSubject.asObservable()
                .map(mController.getMapDateTrancform()) //将Date[]转换为二维列表
                .subscribe(mController.getRefreshListObserver());//接受二维列表, 显示于界面
}


//当选择时间的时候
public void showSelectTimeDialog(final View view) {
	Date[] d = {mStartDate, mEndDate}; //所选的开始时间, 结束时间
	mTimeSearchResultSubject.onNext(d);//传入
}
```

>***注解:***
`onNext`: 提前用`PublicshSubject`定义一个Observable, 并且将整个转换链路定义好, 调用`onNext`的时候相当于广播者发了一条广播

